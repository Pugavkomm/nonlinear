# файл function содержит все необходимые функции для данной модели

# параметры задаем согласно теории (пока не проведены ислледования, то
# используем параметры для кусочно линейной функции

# необходимо обработать код таким образом, чтобы выходом было лишь результат в виде массива
# данных, чтобы его передавать на инструменты выводы, для анализа результатов

# d - коэфицент диффузии, N количество элементов
# данная программа будет моделировать активную среду с кубической нелинейностью
# с переодическими граничными условиями

# так же будем моделировать среду сразу с решением в виде стационарных волн
# так как именно эти решения нас интересуют, так же создадим модели стационарных во времени и
# в пространстве волн.

# скорость распространения волн рассматриваем равной 1, т.е. (с = 1)

# quant_iter - количеств о итераций
# quant_el - количество элементов в цепочке
# a, d - параметры модели
# a - характерезует положение корня кубической функции
# d - коэффициент диффузии

# граничное условие типа кольцо

import numpy as np
import random
import function


def model_cube_ring(quant_el, quant_it, a, d, one_rand, end_rand, alpha):
    #quant_el = quant_el + 1
    # функция моделирует систему, когда решение ищем в виде стац. волн, возвращает матрицу, 1 строка - x, вторая y
    elements_time = np.zeros((2, quant_it))  #первая строка x, второя y. Количество итераций
    #случайные нач. условия в заданном интервале
    elements_time[0][0  ] = random.uniform(one_rand, end_rand)
    elements_time[1][0] = random.uniform(one_rand, end_rand)
    #elements[0][0] = .386
    #elements[1][0] = .351
    #elements[0][0] = 1.45
    #elements[1][0] = .5
    j = 1
    k = 0
    for i in range(1, quant_it):
        if j == quant_el :
            print(i)
            j = 0
            k = k + 1
            elements_time[0][i] = elements_time[1][i - 1]
            elements_time[1][i] = elements_time[1][i - quant_el]
        else:
            elements_time[0][i] = elements_time[1][i - 1]
            elements_time[1][i] = function.stat_iter (a, d, elements_time[0][i - 1], elements_time[1][i - 1], alpha)
        j = j + 1
    return elements_time

